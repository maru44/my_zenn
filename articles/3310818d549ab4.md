---
title: "The Catcher in the Cli / CLIã§ã¤ã‹ã¾ãˆã¦"
emoji: "ğŸ•â€ğŸ¦º"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "oss"]
published: true
---

# ã“ã‚Œã¯ä½•ï¼Ÿ

æ¨™æº–å‡ºåŠ›ã€æ¨™æº–å…¥åŠ›ã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹OSSã€‚ã©ã‚Œã‚’ã‚­ãƒ£ãƒƒãƒã—ã¦ã©ã‚Œã‚’ã‚­ãƒ£ãƒƒãƒã—ãªã„ã‹ã‚‚è¨­å®šã§ãã‚‹ã€‚

ãƒªãƒ³ã‚¯ã¯ã“ã¡ã‚‰
https://github.com/maru44/catcher-in-the-cli

ç”±æ¥ã¯ã‚µãƒªãƒ³ã‚¸ãƒ£ãƒ¼ã®"*The Catcher in the rye*" (ãƒ©ã‚¤éº¦ç•‘ã§ã¤ã‹ã¾ãˆã¦)
æ”»æ®»æ©Ÿå‹•éšŠãŒå¤§å¥½ããªã®ã§å°èª¬å«Œã„ãªè‡ªåˆ†ã§ã‚‚é ‘å¼µã£ã¦èª­ã‚“ã ä½œå“

# ä½¿ã„æ–¹

https://github.com/maru44/catcher-in-the-cli/tree/master/_sample

```go:_sample/main.go
package main

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/maru44/catcher-in-the-cli"
)

func main() {
	ctx := context.Background()

	c := catcher.GenerateCatcher(
		&catcher.Settings{
			Interval: 4000,
			Repeat:   catcher.IntPtr(2),
		},
	)

	go func() {
		select {
		case <-time.After(500 * time.Millisecond):
			fmt.Println("bbb")
			fmt.Println("ccc")

			fmt.Fprintln(os.Stderr, "ddddd")
		}
	}()

	c.CatchWithCtx(ctx, writeFile)
}

func writeFile(ts []*catcher.Caught) {
	f, _ := os.OpenFile("./_sample/log.log", os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600)
	defer f.Close()

	for _, t := range ts {
		f.Write([]byte(t.String() + "\n"))
	}
}

```

ã¾ãš`GenerateCatcher`ã§åˆæœŸåŒ–ã—ã¦ã€`Catch`ã¾ãŸã¯`CatchWithCtx`ãƒ¡ã‚½ãƒƒãƒ‰ã§åˆ©ç”¨ã—ã¾ã™ã€‚
`go run _sample/main.go`ã‚’å®Ÿè¡Œã—ãŸçµæœãŒä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

æ¨™æº–å‡ºåŠ›
```:æ¨™æº–å‡ºåŠ›
aaa
ddddd
exec: "aaa": executable file not found in $PATH
bbb
ccc
ls
LICENSE
README.md
_sample
_sample2
catcher.go
caught.go
domain.go
go.mod
tools.go

```

ä¿å­˜ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«
```:log.log
Output: bbb
Output: ccc
Input: aaa
Error: ddddd
Error: exec: "aaa": executable file not found in $PATH
Output: LICENSE
Output: README.md
Output: _sample
Output: _sample2
Output: catcher.go
Output: caught.go
Output: domain.go
Output: go.mod
Output: tools.go
Input: ls

```

`log.SetOutput()` ã§ååˆ†ï¼Ÿ
ç§ã‚‚æ­£ç›´ãã†æ€ã†

ä½œã£ã¦ã¿ãŸã‹ã£ãŸã‹ã‚‰ã¤ãã£ãŸã®ã 
ãã—ãŸã‚‰ç¾æ™‚ç‚¹ã§ã¯ã‚ã¾ã‚Šå®Ÿç”¨æ€§ã®ãªã„ã‚‚ã®ãŒå‡ºæ¥ä¸ŠãŒã£ã¦ã—ã¾ã£ãŸ(æ”¹è‰¯ã™ã‚Œã°ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã‚‚???)


# ä½•ã‚’ã—ã¦ã„ã‚‹ã‹

## ãƒ¡ã‚¤ãƒ³ã®å‡¦ç†

`context`ãŒçµ‚äº†ã—ã€`stdin`, `stdout`, `stderr`ã‚’ç¢ºèªã—å…¨ã¦çµ‚äº†ã—ã¦ã„ãŸã‚‰ã€`catcher`ã‚’æŒ‡å®šã®separatorã§åˆ†è§£ã™ã‚‹ã€‚
åˆ†è§£ã—ãŸã‚‚ã®ã‚’å¼•æ•°ã«æŒ‡å®šã—ãŸé–¢æ•°ã§ç…®ã‚‹ãªã‚Šç„¼ããªã‚Šå¥½ãã«ã—ã¦ãã‚Œã¨ã„ã†æ„Ÿã˜ã€‚
ã“ã®é–¢æ•°ã‚’`CatchWithCtx`ã¨`Catch`ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ©ãƒƒãƒ—ã—ã¦ãŠã‚Šã€ãã‚Œã‚’å¤–éƒ¨ã‹ã‚‰å‘¼ã³å‡ºã—ã¦ä½¿ã†ã€‚

```go:catcher.go
func (c *catcher) catch(ctx context.Context, ch chan string, f func(cs []*Caught)) {
	c.Times++
	localCtx, cancel := context.WithTimeout(ctx, time.Millisecond*time.Duration(c.Interval))
	defer cancel()

	chOut := make(chan bool)
	chIn := make(chan bool)
	chError := make(chan bool)

	if c.OutBulk != nil {
		go c.catchStdout(localCtx, chOut)
	}
	if c.InBulk != nil {
		go c.catchStdin(localCtx, chIn)
	}
	if c.ErrorBulk != nil {
		go c.catchStderr(localCtx, chError)
	}

	for {
		select {
		case <-localCtx.Done():
			for {
				if c.IsOver(chOut, chIn, chError) {
					cs := c.Separate()
					f(cs)
					c.Reset()
					c.repeat(ch, c.Times)
					return
				}
			}
		case <-ctx.Done():
			for {
				if c.IsOver(chOut, chIn, chError) {
					cs := c.Separate()
					f(cs)
					c.Reset()
					c.repeat(ch, c.Times)
					return
				}
			}
		}
	}
}

```

## stdout (stderr)

`stderr`ã‚‚ã»ã¼åŒæ§˜

`io.Reader`ã‹ã‚‰èª­ã¿å–ã£ãŸã‚‚ã®ã‚’ä¸€æ™‚ä¿å­˜ç”¨ã®bufferã¨æ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã‚€
`context`ãŒçµ‚äº†ã—ãŸã‚‰`catcher`ã®`OutBulk`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¿å­˜ã—ã€ãƒãƒ£ãƒãƒ«ã«`true`ã‚’é€ä¿¡ã€‚
`os.Stdout`ã‚’å…ƒã«ã‚‚ã©ã—ã¦ã€çµ‚äº†ã•ã›ã‚‹
```go:catcher.go
func (c *catcher) catchStdout(ctx context.Context, ch chan bool) {
	r, w, err := os.Pipe()
	if err != nil {
		panic(err)
	}
	stdout := os.Stdout
	os.Stdout = w

	for {
		select {
		case <-ctx.Done():
			w.Close()

			var buf bytes.Buffer
			mw := io.MultiWriter(stdout, &buf)
			io.Copy(mw, r)

			c.OutBulk.Text = buf.String()

			os.Stdout = stdout // restore stdout
			ch <- true
			return
		}
	}
}

```

## stdin
bufio.Scannerã§æ¨™æº–å…¥åŠ›ã‚’å—ã‘å–ã£ã¦ã„ã‚‹
```go:catcher.go
func (c *catcher) catchStdin(ctx context.Context, ch chan bool) {
	scan := bufio.NewScanner(os.Stdin)

	go func() {
		select {
		case <-ctx.Done():
			ch <- true
			return
		}
	}()

	for scan.Scan() {
		c.InBulk.Text += scan.Text() + c.Separator
		com := strings.Split(scan.Text(), " ")
		out, err := exec.Command(com[0], com[1:]...).Output()
		if err != nil {
			fmt.Fprint(os.Stderr, err, c.Separator)
		} else {
			fmt.Print(string(out), c.Separator)
		}
	}
}

```

ã¨ã¾ã‚ã“ã‚“ãªæ„Ÿã˜ã€‚
`catcher`ã«`Interval`ã¨`Repeat`ã‚’è¨­å®šã—ã¦ç¹°ã‚Šè¿”ã—å‡¦ç†ã«ã—ã¦ã„ã‚‹ã®ã¯bufferã«ç„¡é™ã«å †ç©ã—ãªã„ã‚ˆã†ã«ã“ã®ã‚ˆã†ã«ã—ã¦ã¿ãŸ

# æœ€å¾Œã«

è‰¯ã‹ã£ãŸã‚‰ä½¿ã£ã¦ãã ã•ã„
