---
title: "ユースケース図とSRP(単一責任の原則)"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [“go”, “クリーニンアーキテクチャ“, “アーキテクチャ“]
published: false
---

# モチベーション

クリーンアーキテクチャに則り作られた自分の個人開発のプロダクトが SRP を満たしているのか不安になり、ユースケース図を書くことにしました。その際クリーンアーキテクチャ用のユースケース図を思いついたので共有いたします。
おそらく他のアーキテクチャ等でも流用可能だと思うので、気に入ったら是非使ってみてください。
サンプルの drawio のファイルはこちらです。
@TODO ファイルの github url

# 単一責任の原則とは

単一責任の原則とは何か？
色々な言われ方をします。
**一つの関数はたった一つのことを行うべき**
**クラスが担う責任は、たった一つに限定すべき**
等
これらを言い換えると、以下のように言えます。
**モジュールを変更する理由はたった一つであるべき**
ここで毎度おなじみのボブおじさんが以下のように補足します。
「システムの変更ってのは、ユーザーやステークホルダーを満足させるためのものでしょ？それってつまり、ユーザーやステークホルダー自体が SRP の指し示すモジュールを変更する理由なんじゃない？」
「ユーザーやステークホルダーのグループをアクターと呼称したときにこれは以下のように言い換えられるんじゃない？」
**モジュールはたった一つのアクターに対して責務を負うべきである。**
なるほど。完全に合っているかはわかりませんが、一理ありそうですね。

以下この記事では単一責任原則の定義を
**モジュールはたった一つのアクターに対して責務を負うべきである。**
として進めていきます。

# 単一責任の原則を破っている状態

単一責任の原則を破っている状態とその問題点を示したいと思います。
例のごとく go のサンプルコードと今回はユースケース図を交えて解説していきます。

なかなか例を考えるのが難しくてあまりいいコードでないのはご了承ください。

以下のように Transfer という移動距離算出のインターフェースに注目していきます。
既にある程度クリーンアーキテクチャを知っている方であれば単一責任の原則だけでなく、インターフェースの分離にも反している

```go:bad.go
package main

import "fmt"

var (
	space = "space"
	water = "water"
)

// 移動算出
type Transfer interface {
	transferWhite(string, int) int
	transferGreen(string, int) int
	transferRed(string, int) int
}

type MobileSuit struct {
	weight int
	engine int
	name   string
	Transfer
}

// 速度算出
func (m *MobileSuit) calculateSpeedIndex() float32 {
	return float32(m.engine) / float32(m.weight)
}

// ザクタイプ
func (m *MobileSuit) transferZaku(field string, seconds int) int {
	var transfer int
	switch field {
	case space:
		index := m.calculateSpeedIndex()
		transfer = int(index * 1.2 * float32(seconds))
	case water:
		index := m.calculateSpeedIndex()
		transfer = int(index * .4 * float32(seconds))
	default:
		index := m.calculateSpeedIndex()
		transfer = int(index * float32(seconds))
	}
	return transfer
}

// 白い悪魔移動距離算出
func (m *MobileSuit) transferWhite(field string, seconds int) int {
	var transfer int
	switch field {
	case space:
		index := m.calculateSpeedIndex()
		transfer = int(index * 1.2 * float32(seconds))
	case water:
		index := m.calculateSpeedIndex()
		transfer = int(index * .7 * float32(seconds))
	default:
		index := m.calculateSpeedIndex()
		transfer = int(index * float32(seconds))
	}
	return transfer
}

// 移動距離算出
func (m *MobileSuit) transferGreen(field string, seconds int) int {
	return m.transferZaku(field, seconds)
}

// 移動距離算出
func (m *MobileSuit) transferRed(field string, seconds int) int {
	return m.transferZaku(field, seconds)
}

func main() {
	field := space
	white := &MobileSuit{
		weight: 43,
		engine: 55,
		name:   "白い悪魔",
	}
	green := &MobileSuit{
		weight: 58,
		engine: 43,
		name:   "緑の脇役",
	}
	red := &MobileSuit{
		weight: 58,
		engine: 43,
		name:   "赤いの",
	}
	transferWhite := white.transferWhite(field, 200)
	transferGreen := green.transferGreen(field, 200)
	transferRed := red.transferRed(field, 200)
	fmt.Printf(
		"%s: %v, %s: %v, %s: %v",
		white.name, transferWhite, green.name, transferGreen, red.name, transferRed,
	)
}

```
