---
title: "Go ãƒ­ã‚°ã‚’jsonãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹"
emoji: "ğŸ¡"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "log"]
published: true
---

# ã¯ã˜ã‚ã«

åºƒå¤§ã§å¯›å¤§ãªãƒãƒƒãƒˆã®æµ·ã«ã•ã•ã‚„ã‹ãªæ¤œç´¢å¦¨å®³ã‚’ä¸€ç²’æ·»ãˆã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚

# ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³

å€‹äººé–‹ç™ºã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é‹ç”¨ã§ã©ã®ã‚ˆã†ã«ãƒ­ã‚°ã‚’ä¿ç®¡ã—ã€ç®¡ç†ã™ã‚‹ã‹ã‚’è€ƒãˆãŸã“ã¨ãŒå§‹ã¾ã‚Šã§ã™ã€‚
sentry ã«é ¼ã£ãŸã‚Šã€zerolog ã‚„ logrus ç­‰ç´ æ™´ã‚‰ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ã¦ã‚‚ã„ã„ã‘ã©ã€å‹‰å¼·ã‚‚å…¼ã­ã¦ã©ã†ã›ãªã‚‰ go ã®æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§è‡ªä½œã—ã¦ã—ã¾ãˆã¨æ€ã„ä½œã‚Šã¾ã—ãŸã€‚
go ã®ã„ã„ã¨ã“ã‚ã£ã¦ã‚„ã£ã±ã‚Šæ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã¡ã‚‡ã†ã©ã„ã„ã¨ã“ã‚ã ã¨å‹æ‰‹ã«æ€ã£ã¦ã„ã¾ã™ã€‚

# ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™

å¾Œã‹ã‚‰èª­ã‚ã‚‹ãŸã‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã§ã®ä¿ç®¡ã‚’è€ƒãˆã¾ã—ãŸã€‚
ã“ã¡ã‚‰ã¯ log ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¨ã¦ã‚‚ç°¡å˜ã«ã§ãã¾ã™ã€‚

```go:logger.go
package domain

import (
	".../configs"
	".../tools"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"runtime"
	"time"
)


const (
	/******************
	    probrem
	******************/
	// urgency (at once)
	LogAlert = "ALT"
	// urgency (at many times)
	LogCritical = "CRT"
	// need fix without urgency (at many times)
	LogWarn = "WAN"
	/******************
	   no probrem
	******************/
	LogInfo   = "INF"
	/******************
	   no probrem
	******************/
	LogDebug = "DBG"
)

// logå‡ºåŠ›æ±ç”¨é–¢æ•°
func ErrorLogger(err error, mode string) {
    if IsProduction() {
        today := time.Now().Format("20060102")
        lFile, _ := os.OpenFile(fmt.Sprintf("%s/log_%s.log", configs.ErrorLogDirectory, today), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        defer lFile.Close()

		// get called place
		_, file, line, _ := runtime.Caller(1)

		log.SetOutput(lFile) // å‡ºåŠ›å…ˆã®å¤‰æ›´
		log.SetFlags(log.LstdFlags) // ä¸è¦ã€ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘è¶³ã™ã¨ãã«ã¯ã“ã“ã«ãƒ‘ã‚¤ãƒ—ã§è¿½åŠ 

		// set prefix
		var level string
		switch mode {
		case "":
			level = LogInfo
		default:
			level = mode
		}
		log.SetPrefix(level+" ")

		log.Println(fmt.Sprintf("%s:%d: %v", file, line, err))
    } else {
        log.Println(err)
    }
}
```

å°‘ã—è§£èª¬ã—ã¾ã™ã€‚

runtime ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã—ã‚‚ã¨ã®ä½ç½®ã‚’å–å¾—ã—ã¾ã™ã€‚

```go
_, file, line, _ := runtime.Caller(1)
```

SetOutput ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ­ã‚°ã®å‡ºåŠ›å…ˆã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go
log.SetOutput(lFile) // å‡ºåŠ›å…ˆã®å¤‰æ›´
```

ã“ã“ã§ã¯ Laravel ã® Log ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã¿ãŸã„ãªå½¢ã§ãƒ­ã‚°ã®ãƒ¬ãƒ™ãƒ«ã‚’æ¥é ­æ–‡å­—ã¨ã—ã¦ä¸ãˆã¦ã„ã¾ã™ã€‚

```go
// set prefix
var level string
switch mode {
case "":
	level = LogInfo
default:
	level = mode
}
log.SetPrefix(level)
```

ã“ã“ã¾ã§ã‚„ã£ã¦ Println ã‚’ã™ã‚‹ã¨ã“ã‚“ãªæ„Ÿã˜ã§ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

```
WAN 2021/07/28 08:05:56 /<ç§˜å¯†>/internal/pkg/interfaces/database/audience_repository.go:121: sql: Rows are closed
WAN 2021/07/28 08:05:58 /<ç§˜å¯†>/internal/pkg/interfaces/database/audience_repository.go:121: sql: Rows are closed
```

# ãƒ­ã‚°ã‚’ json ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™

æ¤œç´¢æ€§ã‚’é«˜ã‚ã€éšå±¤åŒ–ã‚‚å¯èƒ½ãª json ã«ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

## json ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›

ãã®éš›ã«ã¾ãš json ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãå‡ºã—ã§ä¸€å·¥å¤«å¿…è¦ã ã£ãŸã®ã§ã€å…±æœ‰ã—ã¾ã™ã€‚

json ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã®ã‚„ã‚Šæ–¹ã¨ã—ã¦ã¯ 2 é€šã‚Šè€ƒãˆã¾ã—ãŸã€‚

1. ä¸¸ã”ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã™ã‚‹
2. å¿…è¦ãªåˆ†ã ã‘ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã™ã‚‹

1 ã®ã‚„ã‚Šæ–¹ã‚’å°‘ã—ä¹±æš´ã«æ„Ÿã˜ãŸã“ã¨ã€ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’ã¨ã£ãŸçµæœå°‘ã—ã ã‘ 2 ã®æ–¹æ³•ã®æ–¹ãŒå„ªã‚Œã¦ã„ãŸãŸã‚ 2 ã‚’çµæœçš„ã«æ¡ç”¨ã—ã¾ã—ãŸã€‚
1 ã®ã‚„ã‚Šæ–¹ã¨ãƒ†ã‚¹ãƒˆã¨ãã®çµæœã¯ä¸€ç•ªæœ€å¾Œã«è£œè¶³ã¨ã—ã¦ã¤ã‘ã¦ãŠãã¾ã™ã€‚

2 ã®ã‚„ã‚Šæ–¹(è¿½è¨˜æ³•)

```go:logger.go
func writeJsonFile(fileName string, object interface{}) {
	file, _ := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	defer file.Close()
	fi, _ := file.Stat()
	leng := fi.Size()

	json_, _ := json.Marshal(object)

	if leng == 0 {
		file.Write([]byte(fmt.Sprintf(`[%s]`, json_)))
	} else {
		file.WriteAt([]byte(fmt.Sprintf(`,%s]`, json_)), leng-1)
	}
}
```

ã¾ãšæ›¸ãè¾¼ã¿ãŸã„ã‚‚ã®ã‚’ json åŒ–ã—ã¾ã™ã€‚

æ¬¡ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®é•·ã•ã‚’å–å¾—ã—ã¾ã™ã€‚
æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚Œã°ãã®ã¾ã¾å‡ºåŠ›ã€
ãã†ã§ãªã„å ´åˆæœ€å¾Œã® 1 æ–‡å­—(`]`)ã‚’`,<è¿½åŠ åˆ†>]`ã®æ–‡å­—åˆ—ã§ä¸Šæ›¸ãã—ã¦ã„ã¾ã™ã€‚

## ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’ json ã«ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€

å…ˆç¨‹ã® writeJson()ã‚’ä½¿ã£ã¦ã“ã‚“ãªæ„Ÿã˜ã§æ›¸ã‘ã¾ã™ã€‚

å…¨æ–‡ä¸€æ°—ã«ã„ã£ã¦ã—ã¾ã„ã¾ã™ã€‚

```go:logger.go
package domain

import (
	"animar/v1/configs"
	"animar/v1/internal/pkg/tools/tools"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"runtime"
	"time"
)

const (
	/******************
	    probrem
	******************/
	// urgency (at once)
	LogAlert = "ALT"
	// urgency (at many times)
	LogCritical = "CRT"
	// need fix without urgency
	LogWarn = "WAN"
	/******************
	   no probrem
	******************/
	LogInfo = "INF"
	/******************
	   no probrem
	******************/
	LogDebug = "DBG"
)

// Logã®åŸºåº•æ§‹é€ ä½“
type Log struct {
	Kind  string    `json:"kind"`
	Time  time.Time `json:"time"`
	Level string    `json:"level"`
}

// Errorç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogE struct {
	Log
	Content string `json:"content"` // ã‚¨ãƒ©ãƒ¼å†…å®¹
	Place   string `json:"place"` // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿå ´æ‰€
}

// Accessç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogA struct {
	Log
	Address string `json:"address"` // IPã‚¢ãƒ‰ãƒ¬ã‚¹
	Method  string `json:"method"` // request method
	Path    string `json:"path"` // path
}

func NewAccessLog() *LogA {
	// startã®logã‚’ã“ã“ã§ä½œã‚‹
	alog := &LogA{
		Log: Log{
			Kind: "access",
		},
	}
	return alog
}

func newErrorLog() *LogE {
	eLog := &LogE{
		Log: Log{
			Kind: "error",
		},
	}
	return eLog
}

func ErrorAlert(err error) {
	e := newErrorLog()
	e.Logging(err, LogAlert)
}

func ErrorCritical(err error) {
	e := newErrorLog()
	e.Logging(err, LogCritical)
}

func ErrorWarn(err error) {
	e := newErrorLog()
	e.Logging(err, LogWarn)
}

func (e *LogE) Logging(err error, level string) {
	if tools.IsProductionEnv() {
		e.write(err, level)
	} else {
		e.write(err, level)
	}
}

func (a *LogA) Logging(r *http.Request) {
	if tools.IsProductionEnv() {
		a.write(r)
	} else {
		a.write(r)
	}
}

func (a *LogA) write(r *http.Request) {
	today := time.Now().Format("20060102")

	a.Level = LogInfo
	a.Time = time.Now()
	a.Address = r.RemoteAddr
	a.Method = r.Method
	a.Path = r.URL.Path

	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), a)
}

func (e *LogE) write(err error, level string) {
	today := time.Now().Format("20060102")

	e.Level = level
	e.Content = err.Error()

	// auto
	_, file, line, _ := runtime.Caller(3))
	e.Place = fmt.Sprintf("%s:%d", file, line)
	e.Time = time.Now()

	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), e)
}

// ä¸Šã§è§£èª¬ã—ãŸjson fileæ›¸ãè¾¼ã¿é–¢æ•°
func writeJsonFile(fileName string, object interface{}) {
	file, _ := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	defer file.Close()
	fi, _ := file.Stat()
	leng := fi.Size()

	json_, _ := json.Marshal(object)

	if leng == 0 {
		file.Write([]byte(fmt.Sprintf(`[%s]`, json_)))
	} else {
		file.WriteAt([]byte(fmt.Sprintf(`,%s]`, json_)), leng-1)
	}
}

func HttpLog(h http.Handler, l *LogA) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		l.Logging(r)
		h.ServeHTTP(w, r)
	})
}
```

ç´°ã‹ãè§£èª¬ã—ã¾ã™ã€‚

ã“ã“ã§ã¯æ§‹é€ ä½“ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã‚‚ã©ã¡ã‚‰ã‚‚ Log æ§‹é€ ä½“ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚

```go
// Logã®åŸºåº•æ§‹é€ ä½“
type Log struct {
	Kind  string    `json:"kind"`
	Time  time.Time `json:"time"`
	Level string    `json:"level"`
}

// Errorç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogE struct {
	Log
	Content string `json:"content"` // ã‚¨ãƒ©ãƒ¼å†…å®¹
	Place   string `json:"place"` // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿå ´æ‰€
}

// Accessç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogA struct {
	Log
	Address string `json:"address"` // IPã‚¢ãƒ‰ãƒ¬ã‚¹
	Method  string `json:"method"` // request method
	Path    string `json:"path"` // path
}
```

åˆæœŸåŒ–ã«éš›ã—ã¦ã¯ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ kind ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒãŸã›ã¦ã„ã¾ã™ã€‚

```go
func NewAccessLog() *LogA {
	// startã®logã‚’ã“ã“ã§ä½œã‚‹
	alog := &LogA{
		Log: Log{
			Kind: "access",
		},
	}
	return alog
}

func newErrorLog() *LogE {
	eLog := &LogE{
		Log: Log{
			Kind: "error",
		},
	}
	return eLog
}
```

ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã¯ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§å³å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

```go
func ErrorAlert(err error) {
	e := newErrorLog()
	e.Logging(err, LogAlert)
}

func ErrorCritical(err error) {
	e := newErrorLog()
	e.Logging(err, LogCritical)
}

func ErrorWarn(err error) {
	e := newErrorLog()
	e.Logging(err, LogWarn)
}

func (e *LogE) Logging(err error, level string) {
	if tools.IsProductionEnv() {
		e.write(err, level)
	} else {
		e.write(err, level)
	}
}

func (e *LogE) write(err error, level string) {
	today := time.Now().Format("20060102")

	e.Level = level
	e.Content = err.Error()

	// auto
	_, file, line, _ := runtime.Caller(2)
	e.Place = fmt.Sprintf("%s:%d", file, line)
	e.Time = time.Now()

	// å‰ç« ã§è§£èª¬ã—ã¦ãŸjsonãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿é–¢æ•°
	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), e)
}
```

ä¸€æ–¹ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã®æ–¹ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã”ã¨ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã„å›ã™å½¢ã§ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

```go
func (a *LogA) Logging(r *http.Request) {
	if tools.IsProductionEnv() {
		a.write(r)
	} else {
		a.write(r)
	}
}

func (a *LogA) write(r *http.Request) {
	today := time.Now().Format("20060102")

	a.Level = LogInfo
	a.Time = time.Now()
	a.Address = r.RemoteAddr
	a.Method = r.Method
	a.Path = r.URL.Path

	// å‰ç« ã§è§£èª¬ã—ã¦ãŸjsonãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿é–¢æ•°
	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), a)
}

// ã‚¢ã‚¯ã‚»ã‚¹ã«é–¢ã™ã‚‹ãƒ­ã‚°ã‚’åãå‡ºã™é–¢æ•°
func HttpLog(h http.Handler, l *LogA) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		l.Logging(r)
		h.ServeHTTP(w, r)
	})
}
```

å®Ÿéš›ã«ã¯ã“ã‚“ãªæ„Ÿã˜ã§ä½¿ã„ã¾ã™ã€‚

```go:main.go
package main

import (
	"net/http"
	".../domain"
)

func main() {
	router := http.NewServeMux()
	l := domain.NewAccessLog()

	router.Handle(...)

	...

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«HttpLogãŒç™ºå‹•ã—ã¾ã™ã€‚
	if err := http.ListenAndServe(":8000", domain.HttpLog(router, l)); err != nil {
		domain.ErrorAlert(err)
	}
}
```

å‡ºåŠ›çµæœã¯ã“ã‚“ãªæ„Ÿã˜ã§ã™ã€‚(jq ã—ã¦ã¾ã™)

```json
[
  {
    "kind": "error",
    "time": "2021-08-05T07:38:54.051566671+09:00",
    "level": "WAN",
    "content": "sql: Rows are closed",
    "place": "<ç§˜å¯†>/internal/pkg/interfaces/database/review_repository.go:74"
  },
  {
    "kind": "access",
    "time": "2021-08-05T07:41:00.609925853+09:00",
    "level": "INF",
    "address": "52.00.000.000",
    "method": "GET",
    "path": "/db/anime/"
  }
]
```

# ã¾ã¨ã‚

go ã§ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã€‚
ã•ã‚‰ã«ãƒ­ã‚°ã‚’ json å½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚

ä»Šå¾Œã¯ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã‚’è¿½åŠ ã—ãŸã‚Šã€ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã¨ãã«ã¯å³åº§ã« slack é€šçŸ¥ã‚’é€ã‚‹æ©Ÿèƒ½ã®è¿½åŠ ã€ãƒãƒƒãƒå‡¦ç†ã§ãƒ­ã‚°ã‚’å®šæœŸçš„ã«å›åã—ã¦ sentry ã®ã‚ˆã†ã«ç”»é¢ã‹ã‚‰è¦‹ã‚Œã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ã¨æ€ã£ã¦ã„ã¾ã™ã€‚

æœ€çµ‚çš„ã« sentry ã‚’ä½¿ã†ã¨æ±ºæ–­ã—ãŸã¨ã—ã¦ã‚‚ã“ã†ã‚„ã£ã¦è‡ªåˆ†ã§ãã‚Œã£ã½ãä½œã£ã¦ã¿ã‚‹ã¨è‰²ã€…å­¦ã¹ã¦é¢ç™½ã„ã§ã™ã­ã€‚
ã“ã†ã‚„ã£ã¦è‡ªç”±ã«å®Ÿé¨“ã§ãã‚‹ã®ãŒå€‹äººé–‹ç™ºã®ã„ã„ã¨ã“ã§ã™ã­ã€‚

# è£œè¶³ ä¸Šæ›¸ãæ³•ã¨ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æ¯”è¼ƒ

ä¸Šæ›¸ãæ³•
ãã‚‚ãã‚‚æ›¸ãæ–¹è‡ªä½“å¾®å¦™ãªæ°—ãŒã™ã‚‹
ã‚‚ã£ã¨ã‚¹ãƒƒã‚­ãƒªã—ãŸæ›¸ãæ–¹ãŒã‚ã‚‹ã¯ãš

```go:overrite.go
func overWrite(fileName string, object interface{}) {
	file, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		fmt.Print(err)
	}
	defer file.Close()
â€‹
	buf := make([]byte, 1024*1024)
	for {
		n, err := file.Read(buf)
		if n == 0 {
			break
		}
		if err != nil {
			panic(err)
		}
	}
	// resize
	idx := bytes.IndexByte(buf, 0)
	buf = buf[:idx]
â€‹
	var lst []interface{}
	json.Unmarshal(buf, &lst)
	lst = append(lst, object)
	json_, _ := json.Marshal(lst)
	file.WriteAt(json_, 0)
}
```

ã‚„ã£ã¦ã‚‹ã“ã¨ã¨ã—ã¦ã¯ã€å…ƒã€…ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ã‹ã‚Œã¦ã„ãŸéƒ¨åˆ†ã‚’ json ã‹ã‚‰ slice ã«å¤‰æ›ã—ã¦æ–°è¦ç´ ã‚’ append ã—ã¦ã„ã¾ã™ã€‚
ãã—ã¦ãã‚Œã‚’ json ã«ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸Šæ›¸ãã™ã‚‹ã€‚ã¨ã„ã£ãŸæ–¹æ³•ã§ã™ã€‚
ãªã‚“ã‹ã‚¯ãƒ‰ã„
â€‹
ä»¥ä¸‹ã«ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æ¸¬å®šã®çµæœã‚‚è¼‰ã›ã¦ãŠãã¾ã™ã€‚
ãã“ã¾ã§å¤§ããªå·®ã¯ãªã„ã§ã™ãŒã€æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚‚è¿½è¨˜ã™ã‚‹ã‚„ã‚Šæ–¹ã®æ–¹ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè‰¯ã„ã¿ãŸã„ã§ã™ã€‚
â€‹

```go:jsonwrite_test.go
package jsonwrite_test
â€‹
import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"testing"
)
â€‹
// è¦ç´ ã‚’è¿½åŠ  (æ—¢å­˜)
func BenchmarkAppend_AppendJson(b *testing.B) {
	b.ResetTimer()
	p := &Sample{Name: "Jhone Doe", Old: 20, Explain: "aaaa aaaa"}
	appendJson(filePath, p)
}
â€‹
// ã¾ã‚‹ã”ã¨æ›¸ãæ›ãˆ (æ—¢å­˜)
func BenchmarkAppend_Overwrite(b *testing.B) {
	b.ResetTimer()
	p := &Sample{Name: "Jhone Doe", Old: 20, Explain: "aaaa aaaa"}
	overWrite(filePath2, p)
}
â€‹
// è¦ç´ ã‚’è¿½åŠ  (æ–°è¦)
func BenchmarkAppend_AppendJsonNew(b *testing.B) {
	b.ResetTimer()
	p := &Sample{Name: "Jhone Doe", Old: 20, Explain: "aaaa aaaa"}
	appendJson(noFilePath, p)
}
â€‹
// ã¾ã‚‹ã”ã¨æ›¸ãæ›ãˆ (æ–°è¦)
func BenchmarkAppend_OverwriteNew(b *testing.B) {
	b.ResetTimer()
	p := &Sample{Name: "Jhone Doe", Old: 20, Explain: "aaaa aaaa"}
	overWrite(noFilePath2, p)
}
â€‹
// delete file
func BenchmarkAppend_DeleteFile(b *testing.B) {
	b.ResetTimer()
	os.Remove(noFilePath)
	os.Remove(noFilePath2)
}
â€‹
const filePath = "./sample.json"
const noFilePath = "./no.json"
const filePath2 = "./sample2.json"
const noFilePath2 = "./no2.json"
â€‹
type Sample struct {
	Name    string `json:"name"`
	Old     int    `json:"old,omitempty"`
	Explain string `json:"explain"`
}
â€‹
func appendJson(fileName string, object interface{}) {
	file, _ := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	defer file.Close()
	fi, _ := file.Stat()
	leng := fi.Size()
â€‹
	json_, _ := json.Marshal(object)
â€‹
	if leng == 0 {
		file.Write([]byte(fmt.Sprintf(`[%s]`, json_)))
	} else {
		file.WriteAt([]byte(fmt.Sprintf(`,%s]`, json_)), leng-1)
	}
}
â€‹
func overWrite(fileName string, object interface{}) {
	file, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		fmt.Print(err)
	}
	defer file.Close()
â€‹
	buf := make([]byte, 1024*1024)
	for {
		n, err := file.Read(buf)
		if n == 0 {
			break
		}
		if err != nil {
			panic(err)
		}
	}
	// resize
	idx := bytes.IndexByte(buf, 0)
	buf = buf[:idx]
â€‹
	var lst []interface{}
	json.Unmarshal(buf, &lst)
	lst = append(lst, object)
	json_, _ := json.Marshal(lst)
	file.WriteAt(json_, 0)
}
â€‹
// result
/******************************
BenchmarkAppend_AppendJson-8            1000000000               0.001882 ns/op        0 B/op          0 allocs/op
BenchmarkAppend_Overwrite-8             1000000000               0.004287 ns/op        0 B/op          0 allocs/op
BenchmarkAppend_AppendJsonNew-8         1000000000               0.002100 ns/op        0 B/op          0 allocs/op
BenchmarkAppend_OverwriteNew-8          1000000000               0.003463 ns/op        0 B/op          0 allocs/op
******************************/
â€‹
```

# å‚è€ƒè³‡æ–™ç­‰

https://qiita.com/nanasess/items/350e59b29cceb2f122b3

https://zenn.dev/spiegel/books/error-handling-in-golang
