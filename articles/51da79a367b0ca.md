---
title: "Goã§ãƒ­ã‚°ã‚’jsonå½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹"
emoji: "ğŸ¡"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "log"]
published: false
---

# ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³

å€‹äººé–‹ç™ºã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é‹ç”¨ã§ã©ã®ã‚ˆã†ã«ãƒ­ã‚°ã‚’ä¿ç®¡ã—ã€ç®¡ç†ã™ã‚‹ã‹ã‚’è€ƒãˆãŸã“ã¨ãŒå§‹ã¾ã‚Šã§ã™ã€‚
sentry ã«é ¼ã£ãŸã‚Šã€zerolog ã‚„ logrus ç­‰ç´ æ™´ã‚‰ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ã¦ã‚‚ã„ã„ã‘ã©ã€å‹‰å¼·ã‚‚å…¼ã­ã¦ã©ã†ã›ãªã‚‰ go ã®æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§è‡ªä½œã—ã¦ã—ã¾ãˆã¨æ€ã„ä½œã‚Šã¾ã—ãŸã€‚
go ã®ã„ã„ã¨ã“ã‚ã£ã¦ã‚„ã£ã±ã‚Šæ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã¡ã‚‡ã†ã©ã„ã„ã¨ã“ã‚ã ã¨å‹æ‰‹ã«æ€ã£ã¦ã„ã¾ã™ã€‚

å–ã‚Šæ•¢ãˆãšã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã ã‘ä½œã‚Šã¾ã—ãŸã€‚ã‚¢ã‚¯ã‚»ã‚¹ç³»ã®ãƒ­ã‚°ã‚‚å¾Œã§ä½œã‚ã†ã¨æ€ã„ã¾ã™ã€‚

# ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™

å¾Œã‹ã‚‰èª­ã‚ã‚‹ãŸã‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã§ã®ä¿ç®¡ã‚’è€ƒãˆã¾ã—ãŸã€‚
ã“ã¡ã‚‰ã¯ log ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¨ã¦ã‚‚ç°¡å˜ã«ã§ãã¾ã™ã€‚
ãƒ™ã‚¿ãƒ™ã‚¿ã®é–¢æ•°ã§ãƒ€ã‚µã„ã®ã§å¿…è¦ã«å¿œã˜ã¦ interface ã¨ã‹ã‚’ä½¿ã£ã¦ã‹ã£ã“ã‚ˆãã—ã¾ã™ã€‚

```go:logger.go
package domain

import (
	".../configs"
	".../tools"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"runtime"
	"time"
)


const (
	/******************
	    probrem
	******************/
	// urgency (at once)
	LogAlert = "ALT"
	// urgency (at many times)
	LogCritical = "CRT"
	// need fix without urgency (at many times)
	LogWarn = "WAN"
	/******************
	   no probrem
	******************/
	LogInfo   = "INF"
	/******************
	   no probrem
	******************/
	LogDebug = "DBG"
)

// logå‡ºåŠ›æ±ç”¨é–¢æ•°
func ErrorLogger(err error, mode string) {
    if IsProduction() {
        today := time.Now().Format("20060102")
        lFile, _ := os.OpenFile(fmt.Sprintf("%s/log_%s.log", configs.ErrorLogDirectory, today), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        defer lFile.Close()

		// get called place
		_, file, line, _ := runtime.Caller(1)

		log.SetOutput(lFile) // å‡ºåŠ›å…ˆã®å¤‰æ›´
		log.SetFlags(log.LstdFlags) // ä¸è¦ã€ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘è¶³ã™ã¨ãã«ã¯ã“ã“ã«ãƒ‘ã‚¤ãƒ—ã§è¿½åŠ 

		// set prefix
		var level string
		switch mode {
		case "":
			level = LogInfo
		default:
			level = mode
		}
		log.SetPrefix(level)

		log.Println(fmt.Sprintf("%s:%d: %v", file, line, err))
    } else {
        log.Println(err)
    }
}
```

å°‘ã—è§£èª¬ã—ã¾ã™ã€‚

runtime ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã—ã‚‚ã¨ã®ä½ç½®ã‚’å–å¾—ã—ã¾ã™ã€‚

```go
_, file, line, _ := runtime.Caller(1)
```

SetOutput ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ­ã‚°ã®å‡ºåŠ›å…ˆã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go
log.SetOutput(lFile) // å‡ºåŠ›å…ˆã®å¤‰æ›´
```

ã“ã“ã§ã¯ Laravel ã® Log ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã¿ãŸã„ãªå½¢ã§ãƒ­ã‚°ã®ãƒ¬ãƒ™ãƒ«ã‚’æ¥é ­æ–‡å­—ã¨ã—ã¦ä¸ãˆã¦ã„ã¾ã™ã€‚

```go
// set prefix
var level string
switch mode {
case "":
	level = LogInfo
default:
	level = mode
}
log.SetPrefix(level)
```

ã“ã“ã¾ã§ã‚„ã£ã¦ Println ã‚’ã™ã‚‹ã¨ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚Šã¾ã™ã€‚

#TODO:ADD ãƒ­ã‚°ã®çµæœ

# ãƒ­ã‚°ã‚’ json ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™

æ¤œç´¢æ€§ã‚’é«˜ã‚ã€éšå±¤åŒ–ã‚‚å¯èƒ½ãª json ã«ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

## json ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›

ãã®éš›ã«ã¾ãš json ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãå‡ºã—ã§ä¸€å·¥å¤«å¿…è¦ã ã£ãŸã®ã§ã€å…±æœ‰ã—ã¾ã™ã€‚

json ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã®ã‚„ã‚Šæ–¹ã¨ã—ã¦ã¯ 2 é€šã‚Šè€ƒãˆã¾ã—ãŸã€‚

1. ä¸¸ã”ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã™ã‚‹
2. å¿…è¦ãªåˆ†ã ã‘ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã™ã‚‹

1 ã®ã‚„ã‚Šæ–¹ã‚’å°‘ã—ä¹±æš´ã«æ„Ÿã˜ãŸã“ã¨ã€ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’ã¨ã£ãŸçµæœå°‘ã—ã ã‘ 2 ã®æ–¹æ³•ã®æ–¹ãŒå„ªã‚Œã¦ã„ãŸãŸã‚ 2 ã‚’çµæœçš„ã«æ¡ç”¨ã—ã¾ã—ãŸã€‚
1 ã®ã‚„ã‚Šæ–¹ã¨ãƒ†ã‚¹ãƒˆã¨ãã®çµæœã¯ä¸€ç•ªæœ€å¾Œã«è£œè¶³ã¨ã—ã¦ã¤ã‘ã¦ãŠãã¾ã™ã€‚

2 ã®ã‚„ã‚Šæ–¹

```go:logger.go
func writeJsonFile(fileName string, object interface{}) {
	file, _ := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	defer file.Close()
	fi, _ := file.Stat()
	leng := fi.Size()

	json_, _ := json.Marshal(object)

	if leng == 0 {
		file.Write([]byte(fmt.Sprintf(`[%s]`, json_)))
	} else {
		file.WriteAt([]byte(fmt.Sprintf(`,%s]`, json_)), leng-1)
	}
}
```

ã¾ãšæ›¸ãè¾¼ã¿ãŸã„ã‚‚ã®ã‚’ json åŒ–ã—ã¾ã™ã€‚

æ¬¡ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®é•·ã•ã‚’å–å¾—ã—ã¾ã™ã€‚
æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚Œã°ãã®ã¾ã¾å‡ºåŠ›ã€
ãã†ã§ãªã„å ´åˆæœ€å¾Œã® 1 æ–‡å­—(`]`)ã‚’`,<è¿½åŠ åˆ†>]`ã®æ–‡å­—åˆ—ã§ä¸Šæ›¸ãã—ã¦ã„ã¾ã™ã€‚

## ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’ json ã«ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€

å…ˆç¨‹ã® writeJson()ã‚’ä½¿ã£ã¦ã“ã‚“ãªæ„Ÿã˜ã§æ›¸ã‘ã¾ã™ã€‚

å…¨æ–‡ä¸€æ°—ã«ã„ã£ã¦ã—ã¾ã„ã¾ã™ã€‚

```go:logger.go
package domain

import (
	"animar/v1/configs"
	"animar/v1/internal/pkg/tools/tools"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"runtime"
	"time"
)

const (
	/******************
	    probrem
	******************/
	// urgency (at once)
	LogAlert = "ALT"
	// urgency (at many times)
	LogCritical = "CRT"
	// need fix without urgency
	LogWarn = "WAN"
	/******************
	   no probrem
	******************/
	LogInfo = "INF"
	/******************
	   no probrem
	******************/
	LogDebug = "DBG"
)

// Logã®åŸºåº•æ§‹é€ ä½“
type Log struct {
	Kind  string    `json:"kind"`
	Time  time.Time `json:"time"`
	Level string    `json:"level"`
}

// Errorç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogE struct {
	Log
	Content string `json:"content"` // ã‚¨ãƒ©ãƒ¼å†…å®¹
	Place   string `json:"place"` // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿå ´æ‰€
}

// Accessç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogA struct {
	Log
	Address string `json:"address"` // IPã‚¢ãƒ‰ãƒ¬ã‚¹
	Method  string `json:"method"` // request method
	Path    string `json:"path"` // path
}

func NewAccessLog() *LogA {
	// startã®logã‚’ã“ã“ã§ä½œã‚‹
	alog := &LogA{
		Log: Log{
			Kind: "access",
		},
	}
	return alog
}

func newErrorLog() *LogE {
	eLog := &LogE{
		Log: Log{
			Kind: "error",
		},
	}
	return eLog
}

func ErrorAlert(err error) {
	e := newErrorLog()
	e.Logging(err, LogAlert)
}

func ErrorCritical(err error) {
	e := newErrorLog()
	e.Logging(err, LogCritical)
}

func ErrorWarn(err error) {
	e := newErrorLog()
	e.Logging(err, LogWarn)
}

func (e *LogE) Logging(err error, level string) {
	if tools.IsProductionEnv() {
		e.write(err, level)
	} else {
		e.write(err, level)
	}
}

func (a *LogA) Logging(r *http.Request) {
	if tools.IsProductionEnv() {
		a.write(r)
	} else {
		a.write(r)
	}
}

func (a *LogA) write(r *http.Request) {
	today := time.Now().Format("20060102")

	a.Level = LogInfo
	a.Time = time.Now()
	a.Address = r.RemoteAddr
	a.Method = r.Method
	a.Path = r.URL.Path

	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), a)
}

func (e *LogE) write(err error, level string) {
	today := time.Now().Format("20060102")

	e.Level = level
	e.Content = err.Error()

	// auto
	_, file, line, _ := runtime.Caller(2)
	e.Place = fmt.Sprintf("%s:%d", file, line)
	e.Time = time.Now()

	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), e)
}

// ä¸Šã§è§£èª¬ã—ãŸjson fileæ›¸ãè¾¼ã¿é–¢æ•°
func writeJsonFile(fileName string, object interface{}) {
	file, _ := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0600)
	defer file.Close()
	fi, _ := file.Stat()
	leng := fi.Size()

	json_, _ := json.Marshal(object)

	if leng == 0 {
		file.Write([]byte(fmt.Sprintf(`[%s]`, json_)))
	} else {
		file.WriteAt([]byte(fmt.Sprintf(`,%s]`, json_)), leng-1)
	}
}

func HttpLog(h http.Handler, l *LogA) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		l.Logging(r)
		h.ServeHTTP(w, r)
	})
}
```

ç´°ã‹ãè§£èª¬ã—ã¾ã™ã€‚

ã“ã“ã§ã¯æ§‹é€ ä½“ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã‚‚ã©ã¡ã‚‰ã‚‚ Log æ§‹é€ ä½“ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚

```go
// Logã®åŸºåº•æ§‹é€ ä½“
type Log struct {
	Kind  string    `json:"kind"`
	Time  time.Time `json:"time"`
	Level string    `json:"level"`
}

// Errorç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogE struct {
	Log
	Content string `json:"content"` // ã‚¨ãƒ©ãƒ¼å†…å®¹
	Place   string `json:"place"` // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿå ´æ‰€
}

// Accessç”¨ãƒ­ã‚°ã®æ§‹é€ ä½“
type LogA struct {
	Log
	Address string `json:"address"` // IPã‚¢ãƒ‰ãƒ¬ã‚¹
	Method  string `json:"method"` // request method
	Path    string `json:"path"` // path
}
```

åˆæœŸåŒ–ã«éš›ã—ã¦ã¯ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ kind ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒãŸã›ã¦ã„ã¾ã™ã€‚

```go
func NewAccessLog() *LogA {
	// startã®logã‚’ã“ã“ã§ä½œã‚‹
	alog := &LogA{
		Log: Log{
			Kind: "access",
		},
	}
	return alog
}

func newErrorLog() *LogE {
	eLog := &LogE{
		Log: Log{
			Kind: "error",
		},
	}
	return eLog
}
```

ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã¯ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§å³å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

```go
func ErrorAlert(err error) {
	e := newErrorLog()
	e.Logging(err, LogAlert)
}

func ErrorCritical(err error) {
	e := newErrorLog()
	e.Logging(err, LogCritical)
}

func ErrorWarn(err error) {
	e := newErrorLog()
	e.Logging(err, LogWarn)
}

func (e *LogE) Logging(err error, level string) {
	if tools.IsProductionEnv() {
		e.write(err, level)
	} else {
		e.write(err, level)
	}
}

func (e *LogE) write(err error, level string) {
	today := time.Now().Format("20060102")

	e.Level = level
	e.Content = err.Error()

	// auto
	_, file, line, _ := runtime.Caller(2)
	e.Place = fmt.Sprintf("%s:%d", file, line)
	e.Time = time.Now()

	// å‰ç« ã§è§£èª¬ã—ã¦ãŸjsonãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿é–¢æ•°
	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), e)
}
```

ä¸€æ–¹ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã®æ–¹ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã”ã¨ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã„å›ã™å½¢ã§ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

```go
func (a *LogA) Logging(r *http.Request) {
	if tools.IsProductionEnv() {
		a.write(r)
	} else {
		a.write(r)
	}
}

func (a *LogA) write(r *http.Request) {
	today := time.Now().Format("20060102")

	a.Level = LogInfo
	a.Time = time.Now()
	a.Address = r.RemoteAddr
	a.Method = r.Method
	a.Path = r.URL.Path

	// å‰ç« ã§è§£èª¬ã—ã¦ãŸjsonãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿é–¢æ•°
	writeJsonFile(fmt.Sprintf("%s/log_%s.json", configs.ErrorLogDirectory, today), a)
}

// ã‚¢ã‚¯ã‚»ã‚¹ã«é–¢ã™ã‚‹ãƒ­ã‚°ã‚’åãå‡ºã™é–¢æ•°
func HttpLog(h http.Handler, l *LogA) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		l.Logging(r)
		h.ServeHTTP(w, r)
	})
}
```

å®Ÿéš›ã«ã¯ã“ã‚“ãªæ„Ÿã˜ã§ä½¿ã„ã¾ã™ã€‚

```go:main.go
package main

import (
	"net/http"
	".../tools"
	".../domain"
)

func main() {
	router := http.NewServeMux()
	l := domain.NewAccessLog()

	router.Handle(...)

	...

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«HttpLogãŒç™ºå‹•ã—ã¾ã™ã€‚
	if err := http.ListenAndServe(":8000", domain.HttpLog(router, l)); err != nil {
		domain.ErrorAlert(err)
	}
}
```

# ã¾ã¨ã‚

go ã§ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã€‚
ã•ã‚‰ã«ãƒ­ã‚°ã‚’ json å½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚

ä»Šå¾Œã¯ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã‚’è¿½åŠ ã—ãŸã‚Šã€ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã¨ãã«ã¯å³åº§ã« slack é€šçŸ¥ã‚’é€ã‚‹æ©Ÿèƒ½ã®è¿½åŠ ã€ãƒãƒƒãƒå‡¦ç†ã§ãƒ­ã‚°ã‚’å®šæœŸçš„ã«å›åã—ã¦ sentry ã®ã‚ˆã†ã«ç”»é¢ã‹ã‚‰è¦‹ã‚Œã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ã¨æ€ã£ã¦ã„ã¾ã™ã€‚

æœ€çµ‚çš„ã« sentry ã‚’ä½¿ã†ã¨æ±ºæ–­ã—ãŸã¨ã—ã¦ã‚‚ã“ã†ã‚„ã£ã¦è‡ªåˆ†ã§ãã‚Œã£ã½ãä½œã£ã¦ã¿ã‚‹ã¨è‰²ã€…å­¦ã¹ã¦é¢ç™½ã„ã§ã™ã­ã€‚
ã“ã†ã‚„ã£ã¦è‡ªç”±ã«å®Ÿé¨“ã§ãã‚‹ã®ãŒå€‹äººé–‹ç™ºã®ã„ã„ã¨ã“ã§ã™ã­ã€‚

# è£œè¶³ ä¸Šæ›¸ãæ³•ã¨ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æ¯”è¼ƒ
